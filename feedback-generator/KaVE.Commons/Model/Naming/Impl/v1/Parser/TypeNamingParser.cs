/*
 * Copyright 2014 Technische Universität Darmstadt
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *    http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from TypeNaming.g4 by ANTLR 4.5.3

// Unreachable code detected

using System.Text;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;

#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace KaVE.Commons.Model.Naming.Impl.v1.Parser
{
    /**
 * Copyright 2016 Technische Universität Darmstadt
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *    http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

    [System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.3")]
    [System.CLSCompliant(false)]
    public class TypeNamingParser : Antlr4.Runtime.Parser
    {
        public const int
            T__0 = 1,
            T__1 = 2,
            T__2 = 3,
            T__3 = 4,
            T__4 = 5,
            T__5 = 6,
            T__6 = 7,
            T__7 = 8,
            T__8 = 9,
            T__9 = 10,
            T__10 = 11,
            T__11 = 12,
            T__12 = 13,
            T__13 = 14,
            T__14 = 15,
            T__15 = 16,
            T__16 = 17,
            T__17 = 18,
            T__18 = 19,
            T__19 = 20,
            T__20 = 21,
            T__21 = 22,
            T__22 = 23,
            T__23 = 24,
            T__24 = 25,
            T__25 = 26,
            T__26 = 27,
            T__27 = 28,
            UNKNOWN = 29,
            POSNUM = 30,
            LETTER = 31,
            SIGN = 32,
            WS = 33,
            EOL = 34;

        public const int
            RULE_typeEOL = 0,
            RULE_methodEOL = 1,
            RULE_namespaceEOL = 2,
            RULE_assemblyEOL = 3,
            RULE_parameterNameEOL = 4,
            RULE_memberNameEOL = 5,
            RULE_lambdaNameEOL = 6,
            RULE_type = 7,
            RULE_typeParameter = 8,
            RULE_notTypeParameter = 9,
            RULE_regularType = 10,
            RULE_delegateType = 11,
            RULE_arrayType = 12,
            RULE_nestedType = 13,
            RULE_nestedTypeName = 14,
            RULE_resolvedType = 15,
            RULE_namespace = 16,
            RULE_typeName = 17,
            RULE_possiblyGenericTypeName = 18,
            RULE_enumTypeName = 19,
            RULE_interfaceTypeName = 20,
            RULE_structTypeName = 21,
            RULE_simpleTypeName = 22,
            RULE_genericTypePart = 23,
            RULE_genericParam = 24,
            RULE_assembly = 25,
            RULE_regularAssembly = 26,
            RULE_assemblyVersion = 27,
            RULE_assemblyName = 28,
            RULE_memberName = 29,
            RULE_simpleMemberName = 30,
            RULE_propertyName = 31,
            RULE_propertyModifier = 32,
            RULE_bothPropertyModifiers = 33,
            RULE_lambdaName = 34,
            RULE_realLambdaName = 35,
            RULE_method = 36,
            RULE_regularMethod = 37,
            RULE_methodSignature = 38,
            RULE_nonStaticCtor = 39,
            RULE_staticCctor = 40,
            RULE_customMethod = 41,
            RULE_methodDefinition = 42,
            RULE_formalParam = 43,
            RULE_parameterModifier = 44,
            RULE_staticModifier = 45,
            RULE_paramsModifier = 46,
            RULE_optsModifier = 47,
            RULE_refModifier = 48,
            RULE_outModifier = 49,
            RULE_extensionModifier = 50,
            RULE_id = 51,
            RULE_num = 52;

        public static readonly string[] ruleNames =
        {
            "typeEOL",
            "methodEOL",
            "namespaceEOL",
            "assemblyEOL",
            "parameterNameEOL",
            "memberNameEOL",
            "lambdaNameEOL",
            "type",
            "typeParameter",
            "notTypeParameter",
            "regularType",
            "delegateType",
            "arrayType",
            "nestedType",
            "nestedTypeName",
            "resolvedType",
            "namespace",
            "typeName",
            "possiblyGenericTypeName",
            "enumTypeName",
            "interfaceTypeName",
            "structTypeName",
            "simpleTypeName",
            "genericTypePart",
            "genericParam",
            "assembly",
            "regularAssembly",
            "assemblyVersion",
            "assemblyName",
            "memberName",
            "simpleMemberName",
            "propertyName",
            "propertyModifier",
            "bothPropertyModifiers",
            "lambdaName",
            "realLambdaName",
            "method",
            "regularMethod",
            "methodSignature",
            "nonStaticCtor",
            "staticCctor",
            "customMethod",
            "methodDefinition",
            "formalParam",
            "parameterModifier",
            "staticModifier",
            "paramsModifier",
            "optsModifier",
            "refModifier",
            "outModifier",
            "extensionModifier",
            "id",
            "num"
        };

        private static readonly string[] _LiteralNames =
        {
            null,
            "'->'",
            "','",
            "'d:'",
            "'arr('",
            "'):'",
            "'n:'",
            "'+'",
            "'.'",
            "'e:'",
            "'i:'",
            "'s:'",
            "'''",
            "'['",
            "']'",
            "'get'",
            "'set'",
            "'('",
            "')'",
            "']..ctor'",
            "']..cctor'",
            "'].'",
            "'static'",
            "'params '",
            "'opt '",
            "'ref '",
            "'out '",
            "'this '",
            "'0'",
            "'?'",
            null,
            null,
            null,
            null,
            "'\n'"
        };

        private static readonly string[] _SymbolicNames =
        {
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            "UNKNOWN",
            "POSNUM",
            "LETTER",
            "SIGN",
            "WS",
            "EOL"
        };

        public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

        [NotNull]
        public override IVocabulary Vocabulary
        {
            get { return DefaultVocabulary; }
        }

        public override string GrammarFileName
        {
            get { return "TypeNaming.g4"; }
        }

        public override string[] RuleNames
        {
            get { return ruleNames; }
        }

        public override string SerializedAtn
        {
            get { return _serializedATN; }
        }

        public TypeNamingParser(ITokenStream input)
            : base(input)
        {
            Interpreter = new ParserATNSimulator(this, _ATN);
        }

        public class TypeEOLContext : ParserRuleContext
        {
            public TypeContext type()
            {
                return GetRuleContext<TypeContext>(0);
            }

            public ITerminalNode EOL()
            {
                return GetToken(TypeNamingParser.EOL, 0);
            }

            public TypeEOLContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_typeEOL; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterTypeEOL(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitTypeEOL(this);
            }
        }

        [RuleVersion(0)]
        public TypeEOLContext typeEOL()
        {
            TypeEOLContext _localctx = new TypeEOLContext(Context, State);
            EnterRule(_localctx, 0, RULE_typeEOL);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 106;
                    type();
                    State = 107;
                    Match(EOL);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class MethodEOLContext : ParserRuleContext
        {
            public MethodContext method()
            {
                return GetRuleContext<MethodContext>(0);
            }

            public ITerminalNode EOL()
            {
                return GetToken(TypeNamingParser.EOL, 0);
            }

            public MethodEOLContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_methodEOL; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterMethodEOL(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitMethodEOL(this);
            }
        }

        [RuleVersion(0)]
        public MethodEOLContext methodEOL()
        {
            MethodEOLContext _localctx = new MethodEOLContext(Context, State);
            EnterRule(_localctx, 2, RULE_methodEOL);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 109;
                    method();
                    State = 110;
                    Match(EOL);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class NamespaceEOLContext : ParserRuleContext
        {
            public NamespaceContext @namespace()
            {
                return GetRuleContext<NamespaceContext>(0);
            }

            public ITerminalNode EOL()
            {
                return GetToken(TypeNamingParser.EOL, 0);
            }

            public NamespaceEOLContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_namespaceEOL; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterNamespaceEOL(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitNamespaceEOL(this);
            }
        }

        [RuleVersion(0)]
        public NamespaceEOLContext namespaceEOL()
        {
            NamespaceEOLContext _localctx = new NamespaceEOLContext(Context, State);
            EnterRule(_localctx, 4, RULE_namespaceEOL);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 112;
                    @namespace();
                    State = 113;
                    Match(EOL);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class AssemblyEOLContext : ParserRuleContext
        {
            public AssemblyContext assembly()
            {
                return GetRuleContext<AssemblyContext>(0);
            }

            public ITerminalNode EOL()
            {
                return GetToken(TypeNamingParser.EOL, 0);
            }

            public AssemblyEOLContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_assemblyEOL; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterAssemblyEOL(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitAssemblyEOL(this);
            }
        }

        [RuleVersion(0)]
        public AssemblyEOLContext assemblyEOL()
        {
            AssemblyEOLContext _localctx = new AssemblyEOLContext(Context, State);
            EnterRule(_localctx, 6, RULE_assemblyEOL);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 115;
                    assembly();
                    State = 116;
                    Match(EOL);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class ParameterNameEOLContext : ParserRuleContext
        {
            public FormalParamContext formalParam()
            {
                return GetRuleContext<FormalParamContext>(0);
            }

            public ITerminalNode EOL()
            {
                return GetToken(TypeNamingParser.EOL, 0);
            }

            public ParameterNameEOLContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_parameterNameEOL; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterParameterNameEOL(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitParameterNameEOL(this);
            }
        }

        [RuleVersion(0)]
        public ParameterNameEOLContext parameterNameEOL()
        {
            ParameterNameEOLContext _localctx = new ParameterNameEOLContext(Context, State);
            EnterRule(_localctx, 8, RULE_parameterNameEOL);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 118;
                    formalParam();
                    State = 119;
                    Match(EOL);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class MemberNameEOLContext : ParserRuleContext
        {
            public MemberNameContext memberName()
            {
                return GetRuleContext<MemberNameContext>(0);
            }

            public ITerminalNode EOL()
            {
                return GetToken(TypeNamingParser.EOL, 0);
            }

            public MemberNameEOLContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_memberNameEOL; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterMemberNameEOL(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitMemberNameEOL(this);
            }
        }

        [RuleVersion(0)]
        public MemberNameEOLContext memberNameEOL()
        {
            MemberNameEOLContext _localctx = new MemberNameEOLContext(Context, State);
            EnterRule(_localctx, 10, RULE_memberNameEOL);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 121;
                    memberName();
                    State = 122;
                    Match(EOL);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class LambdaNameEOLContext : ParserRuleContext
        {
            public LambdaNameContext lambdaName()
            {
                return GetRuleContext<LambdaNameContext>(0);
            }

            public ITerminalNode EOL()
            {
                return GetToken(TypeNamingParser.EOL, 0);
            }

            public LambdaNameEOLContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_lambdaNameEOL; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterLambdaNameEOL(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitLambdaNameEOL(this);
            }
        }

        [RuleVersion(0)]
        public LambdaNameEOLContext lambdaNameEOL()
        {
            LambdaNameEOLContext _localctx = new LambdaNameEOLContext(Context, State);
            EnterRule(_localctx, 12, RULE_lambdaNameEOL);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 124;
                    lambdaName();
                    State = 125;
                    Match(EOL);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class TypeContext : ParserRuleContext
        {
            public ITerminalNode UNKNOWN()
            {
                return GetToken(TypeNamingParser.UNKNOWN, 0);
            }

            public TypeParameterContext typeParameter()
            {
                return GetRuleContext<TypeParameterContext>(0);
            }

            public RegularTypeContext regularType()
            {
                return GetRuleContext<RegularTypeContext>(0);
            }

            public DelegateTypeContext delegateType()
            {
                return GetRuleContext<DelegateTypeContext>(0);
            }

            public ArrayTypeContext arrayType()
            {
                return GetRuleContext<ArrayTypeContext>(0);
            }

            public TypeContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_type; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterType(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitType(this);
            }
        }

        [RuleVersion(0)]
        public TypeContext type()
        {
            TypeContext _localctx = new TypeContext(Context, State);
            EnterRule(_localctx, 14, RULE_type);
            try
            {
                State = 132;
                ErrorHandler.Sync(this);
                switch (Interpreter.AdaptivePredict(TokenStream, 0, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);
                    {
                        State = 127;
                        Match(UNKNOWN);
                    }
                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);
                    {
                        State = 128;
                        typeParameter();
                    }
                        break;
                    case 3:
                        EnterOuterAlt(_localctx, 3);
                    {
                        State = 129;
                        regularType();
                    }
                        break;
                    case 4:
                        EnterOuterAlt(_localctx, 4);
                    {
                        State = 130;
                        delegateType();
                    }
                        break;
                    case 5:
                        EnterOuterAlt(_localctx, 5);
                    {
                        State = 131;
                        arrayType();
                    }
                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class TypeParameterContext : ParserRuleContext
        {
            public IdContext id()
            {
                return GetRuleContext<IdContext>(0);
            }

            public NotTypeParameterContext notTypeParameter()
            {
                return GetRuleContext<NotTypeParameterContext>(0);
            }

            public ITerminalNode[] WS()
            {
                return GetTokens(TypeNamingParser.WS);
            }

            public ITerminalNode WS(int i)
            {
                return GetToken(TypeNamingParser.WS, i);
            }

            public TypeParameterContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_typeParameter; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterTypeParameter(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitTypeParameter(this);
            }
        }

        [RuleVersion(0)]
        public TypeParameterContext typeParameter()
        {
            TypeParameterContext _localctx = new TypeParameterContext(Context, State);
            EnterRule(_localctx, 16, RULE_typeParameter);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 134;
                    id();
                    State = 143;
                    _la = TokenStream.La(1);
                    if (_la == T__0 || _la == WS)
                    {
                        {
                            State = 136;
                            _la = TokenStream.La(1);
                            if (_la == WS)
                            {
                                {
                                    State = 135;
                                    Match(WS);
                                }
                            }

                            State = 138;
                            Match(T__0);
                            State = 140;
                            _la = TokenStream.La(1);
                            if (_la == WS)
                            {
                                {
                                    State = 139;
                                    Match(WS);
                                }
                            }

                            State = 142;
                            notTypeParameter();
                        }
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class NotTypeParameterContext : ParserRuleContext
        {
            public RegularTypeContext regularType()
            {
                return GetRuleContext<RegularTypeContext>(0);
            }

            public DelegateTypeContext delegateType()
            {
                return GetRuleContext<DelegateTypeContext>(0);
            }

            public ArrayTypeContext arrayType()
            {
                return GetRuleContext<ArrayTypeContext>(0);
            }

            public ITerminalNode UNKNOWN()
            {
                return GetToken(TypeNamingParser.UNKNOWN, 0);
            }

            public IdContext id()
            {
                return GetRuleContext<IdContext>(0);
            }

            public NotTypeParameterContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_notTypeParameter; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterNotTypeParameter(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitNotTypeParameter(this);
            }
        }

        [RuleVersion(0)]
        public NotTypeParameterContext notTypeParameter()
        {
            NotTypeParameterContext _localctx = new NotTypeParameterContext(Context, State);
            EnterRule(_localctx, 18, RULE_notTypeParameter);
            try
            {
                State = 150;
                ErrorHandler.Sync(this);
                switch (Interpreter.AdaptivePredict(TokenStream, 4, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);
                    {
                        State = 145;
                        regularType();
                    }
                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);
                    {
                        State = 146;
                        delegateType();
                    }
                        break;
                    case 3:
                        EnterOuterAlt(_localctx, 3);
                    {
                        State = 147;
                        arrayType();
                    }
                        break;
                    case 4:
                        EnterOuterAlt(_localctx, 4);
                    {
                        State = 148;
                        Match(UNKNOWN);
                    }
                        break;
                    case 5:
                        EnterOuterAlt(_localctx, 5);
                    {
                        State = 149;
                        id();
                    }
                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class RegularTypeContext : ParserRuleContext
        {
            public AssemblyContext assembly()
            {
                return GetRuleContext<AssemblyContext>(0);
            }

            public ResolvedTypeContext resolvedType()
            {
                return GetRuleContext<ResolvedTypeContext>(0);
            }

            public NestedTypeContext nestedType()
            {
                return GetRuleContext<NestedTypeContext>(0);
            }

            public ITerminalNode WS()
            {
                return GetToken(TypeNamingParser.WS, 0);
            }

            public RegularTypeContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_regularType; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterRegularType(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitRegularType(this);
            }
        }

        [RuleVersion(0)]
        public RegularTypeContext regularType()
        {
            RegularTypeContext _localctx = new RegularTypeContext(Context, State);
            EnterRule(_localctx, 20, RULE_regularType);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 154;
                    switch (TokenStream.La(1))
                    {
                        case T__8:
                        case T__9:
                        case T__10:
                        case LETTER:
                        {
                            State = 152;
                            resolvedType();
                        }
                            break;
                        case T__5:
                        {
                            State = 153;
                            nestedType();
                        }
                            break;
                        default:
                            throw new NoViableAltException(this);
                    }
                    State = 156;
                    Match(T__1);
                    State = 158;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 157;
                            Match(WS);
                        }
                    }

                    State = 160;
                    assembly();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class DelegateTypeContext : ParserRuleContext
        {
            public MethodContext method()
            {
                return GetRuleContext<MethodContext>(0);
            }

            public DelegateTypeContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_delegateType; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterDelegateType(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitDelegateType(this);
            }
        }

        [RuleVersion(0)]
        public DelegateTypeContext delegateType()
        {
            DelegateTypeContext _localctx = new DelegateTypeContext(Context, State);
            EnterRule(_localctx, 22, RULE_delegateType);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 162;
                    Match(T__2);
                    State = 163;
                    method();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class ArrayTypeContext : ParserRuleContext
        {
            public ITerminalNode POSNUM()
            {
                return GetToken(TypeNamingParser.POSNUM, 0);
            }

            public TypeContext type()
            {
                return GetRuleContext<TypeContext>(0);
            }

            public ArrayTypeContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_arrayType; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterArrayType(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitArrayType(this);
            }
        }

        [RuleVersion(0)]
        public ArrayTypeContext arrayType()
        {
            ArrayTypeContext _localctx = new ArrayTypeContext(Context, State);
            EnterRule(_localctx, 24, RULE_arrayType);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 165;
                    Match(T__3);
                    State = 166;
                    Match(POSNUM);
                    State = 167;
                    Match(T__4);
                    State = 168;
                    type();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class NestedTypeContext : ParserRuleContext
        {
            public NestedTypeNameContext nestedTypeName()
            {
                return GetRuleContext<NestedTypeNameContext>(0);
            }

            public TypeNameContext typeName()
            {
                return GetRuleContext<TypeNameContext>(0);
            }

            public NestedTypeContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_nestedType; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterNestedType(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitNestedType(this);
            }
        }

        [RuleVersion(0)]
        public NestedTypeContext nestedType()
        {
            NestedTypeContext _localctx = new NestedTypeContext(Context, State);
            EnterRule(_localctx, 26, RULE_nestedType);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 170;
                    Match(T__5);
                    State = 171;
                    nestedTypeName();
                    State = 172;
                    Match(T__6);
                    State = 173;
                    typeName();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class NestedTypeNameContext : ParserRuleContext
        {
            public NestedTypeContext nestedType()
            {
                return GetRuleContext<NestedTypeContext>(0);
            }

            public ResolvedTypeContext resolvedType()
            {
                return GetRuleContext<ResolvedTypeContext>(0);
            }

            public NestedTypeNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_nestedTypeName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterNestedTypeName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitNestedTypeName(this);
            }
        }

        [RuleVersion(0)]
        public NestedTypeNameContext nestedTypeName()
        {
            NestedTypeNameContext _localctx = new NestedTypeNameContext(Context, State);
            EnterRule(_localctx, 28, RULE_nestedTypeName);
            try
            {
                State = 177;
                switch (TokenStream.La(1))
                {
                    case T__5:
                        EnterOuterAlt(_localctx, 1);
                    {
                        State = 175;
                        nestedType();
                    }
                        break;
                    case T__8:
                    case T__9:
                    case T__10:
                    case LETTER:
                        EnterOuterAlt(_localctx, 2);
                    {
                        State = 176;
                        resolvedType();
                    }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class ResolvedTypeContext : ParserRuleContext
        {
            public TypeNameContext typeName()
            {
                return GetRuleContext<TypeNameContext>(0);
            }

            public NamespaceContext @namespace()
            {
                return GetRuleContext<NamespaceContext>(0);
            }

            public ResolvedTypeContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_resolvedType; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterResolvedType(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitResolvedType(this);
            }
        }

        [RuleVersion(0)]
        public ResolvedTypeContext resolvedType()
        {
            ResolvedTypeContext _localctx = new ResolvedTypeContext(Context, State);
            EnterRule(_localctx, 30, RULE_resolvedType);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 180;
                    ErrorHandler.Sync(this);
                    switch (Interpreter.AdaptivePredict(TokenStream, 8, Context))
                    {
                        case 1:
                        {
                            State = 179;
                            @namespace();
                        }
                            break;
                    }
                    State = 182;
                    typeName();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class NamespaceContext : ParserRuleContext
        {
            public IdContext[] id()
            {
                return GetRuleContexts<IdContext>();
            }

            public IdContext id(int i)
            {
                return GetRuleContext<IdContext>(i);
            }

            public NamespaceContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_namespace; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterNamespace(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitNamespace(this);
            }
        }

        [RuleVersion(0)]
        public NamespaceContext @namespace()
        {
            NamespaceContext _localctx = new NamespaceContext(Context, State);
            EnterRule(_localctx, 32, RULE_namespace);
            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);
                {
                    State = 187;
                    ErrorHandler.Sync(this);
                    _alt = 1;
                    do
                    {
                        switch (_alt)
                        {
                            case 1:
                            {
                                {
                                    State = 184;
                                    id();
                                    State = 185;
                                    Match(T__7);
                                }
                            }
                                break;
                            default:
                                throw new NoViableAltException(this);
                        }
                        State = 189;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 9, Context);
                    } while (_alt != 2 && _alt != Antlr4.Runtime.Atn.ATN.InvalidAltNumber);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class TypeNameContext : ParserRuleContext
        {
            public EnumTypeNameContext enumTypeName()
            {
                return GetRuleContext<EnumTypeNameContext>(0);
            }

            public PossiblyGenericTypeNameContext possiblyGenericTypeName()
            {
                return GetRuleContext<PossiblyGenericTypeNameContext>(0);
            }

            public TypeNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_typeName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterTypeName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitTypeName(this);
            }
        }

        [RuleVersion(0)]
        public TypeNameContext typeName()
        {
            TypeNameContext _localctx = new TypeNameContext(Context, State);
            EnterRule(_localctx, 34, RULE_typeName);
            try
            {
                State = 193;
                switch (TokenStream.La(1))
                {
                    case T__8:
                        EnterOuterAlt(_localctx, 1);
                    {
                        State = 191;
                        enumTypeName();
                    }
                        break;
                    case T__9:
                    case T__10:
                    case LETTER:
                        EnterOuterAlt(_localctx, 2);
                    {
                        State = 192;
                        possiblyGenericTypeName();
                    }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class PossiblyGenericTypeNameContext : ParserRuleContext
        {
            public InterfaceTypeNameContext interfaceTypeName()
            {
                return GetRuleContext<InterfaceTypeNameContext>(0);
            }

            public StructTypeNameContext structTypeName()
            {
                return GetRuleContext<StructTypeNameContext>(0);
            }

            public SimpleTypeNameContext simpleTypeName()
            {
                return GetRuleContext<SimpleTypeNameContext>(0);
            }

            public GenericTypePartContext genericTypePart()
            {
                return GetRuleContext<GenericTypePartContext>(0);
            }

            public PossiblyGenericTypeNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_possiblyGenericTypeName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterPossiblyGenericTypeName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitPossiblyGenericTypeName(this);
            }
        }

        [RuleVersion(0)]
        public PossiblyGenericTypeNameContext possiblyGenericTypeName()
        {
            PossiblyGenericTypeNameContext _localctx = new PossiblyGenericTypeNameContext(Context, State);
            EnterRule(_localctx, 36, RULE_possiblyGenericTypeName);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 198;
                    switch (TokenStream.La(1))
                    {
                        case T__9:
                        {
                            State = 195;
                            interfaceTypeName();
                        }
                            break;
                        case T__10:
                        {
                            State = 196;
                            structTypeName();
                        }
                            break;
                        case LETTER:
                        {
                            State = 197;
                            simpleTypeName();
                        }
                            break;
                        default:
                            throw new NoViableAltException(this);
                    }
                    State = 201;
                    _la = TokenStream.La(1);
                    if (_la == T__11)
                    {
                        {
                            State = 200;
                            genericTypePart();
                        }
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class EnumTypeNameContext : ParserRuleContext
        {
            public SimpleTypeNameContext simpleTypeName()
            {
                return GetRuleContext<SimpleTypeNameContext>(0);
            }

            public EnumTypeNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_enumTypeName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterEnumTypeName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitEnumTypeName(this);
            }
        }

        [RuleVersion(0)]
        public EnumTypeNameContext enumTypeName()
        {
            EnumTypeNameContext _localctx = new EnumTypeNameContext(Context, State);
            EnterRule(_localctx, 38, RULE_enumTypeName);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 203;
                    Match(T__8);
                    State = 204;
                    simpleTypeName();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class InterfaceTypeNameContext : ParserRuleContext
        {
            public SimpleTypeNameContext simpleTypeName()
            {
                return GetRuleContext<SimpleTypeNameContext>(0);
            }

            public InterfaceTypeNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_interfaceTypeName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterInterfaceTypeName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitInterfaceTypeName(this);
            }
        }

        [RuleVersion(0)]
        public InterfaceTypeNameContext interfaceTypeName()
        {
            InterfaceTypeNameContext _localctx = new InterfaceTypeNameContext(Context, State);
            EnterRule(_localctx, 40, RULE_interfaceTypeName);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 206;
                    Match(T__9);
                    State = 207;
                    simpleTypeName();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class StructTypeNameContext : ParserRuleContext
        {
            public SimpleTypeNameContext simpleTypeName()
            {
                return GetRuleContext<SimpleTypeNameContext>(0);
            }

            public StructTypeNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_structTypeName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterStructTypeName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitStructTypeName(this);
            }
        }

        [RuleVersion(0)]
        public StructTypeNameContext structTypeName()
        {
            StructTypeNameContext _localctx = new StructTypeNameContext(Context, State);
            EnterRule(_localctx, 42, RULE_structTypeName);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 209;
                    Match(T__10);
                    State = 210;
                    simpleTypeName();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class SimpleTypeNameContext : ParserRuleContext
        {
            public IdContext id()
            {
                return GetRuleContext<IdContext>(0);
            }

            public SimpleTypeNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_simpleTypeName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterSimpleTypeName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitSimpleTypeName(this);
            }
        }

        [RuleVersion(0)]
        public SimpleTypeNameContext simpleTypeName()
        {
            SimpleTypeNameContext _localctx = new SimpleTypeNameContext(Context, State);
            EnterRule(_localctx, 44, RULE_simpleTypeName);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 212;
                    id();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class GenericTypePartContext : ParserRuleContext
        {
            public ITerminalNode POSNUM()
            {
                return GetToken(TypeNamingParser.POSNUM, 0);
            }

            public GenericParamContext[] genericParam()
            {
                return GetRuleContexts<GenericParamContext>();
            }

            public GenericParamContext genericParam(int i)
            {
                return GetRuleContext<GenericParamContext>(i);
            }

            public GenericTypePartContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_genericTypePart; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterGenericTypePart(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitGenericTypePart(this);
            }
        }

        [RuleVersion(0)]
        public GenericTypePartContext genericTypePart()
        {
            GenericTypePartContext _localctx = new GenericTypePartContext(Context, State);
            EnterRule(_localctx, 46, RULE_genericTypePart);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 214;
                    Match(T__11);
                    State = 215;
                    Match(POSNUM);
                    State = 216;
                    Match(T__12);
                    State = 217;
                    genericParam();
                    State = 222;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.La(1);
                    while (_la == T__1)
                    {
                        {
                            {
                                State = 218;
                                Match(T__1);
                                State = 219;
                                genericParam();
                            }
                        }
                        State = 224;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.La(1);
                    }
                    State = 225;
                    Match(T__13);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class GenericParamContext : ParserRuleContext
        {
            public TypeParameterContext typeParameter()
            {
                return GetRuleContext<TypeParameterContext>(0);
            }

            public GenericParamContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_genericParam; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterGenericParam(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitGenericParam(this);
            }
        }

        [RuleVersion(0)]
        public GenericParamContext genericParam()
        {
            GenericParamContext _localctx = new GenericParamContext(Context, State);
            EnterRule(_localctx, 48, RULE_genericParam);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 227;
                    Match(T__12);
                    State = 228;
                    typeParameter();
                    State = 229;
                    Match(T__13);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class AssemblyContext : ParserRuleContext
        {
            public RegularAssemblyContext regularAssembly()
            {
                return GetRuleContext<RegularAssemblyContext>(0);
            }

            public ITerminalNode UNKNOWN()
            {
                return GetToken(TypeNamingParser.UNKNOWN, 0);
            }

            public AssemblyContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_assembly; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterAssembly(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitAssembly(this);
            }
        }

        [RuleVersion(0)]
        public AssemblyContext assembly()
        {
            AssemblyContext _localctx = new AssemblyContext(Context, State);
            EnterRule(_localctx, 50, RULE_assembly);
            try
            {
                State = 233;
                switch (TokenStream.La(1))
                {
                    case LETTER:
                        EnterOuterAlt(_localctx, 1);
                    {
                        State = 231;
                        regularAssembly();
                    }
                        break;
                    case UNKNOWN:
                        EnterOuterAlt(_localctx, 2);
                    {
                        State = 232;
                        Match(UNKNOWN);
                    }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class RegularAssemblyContext : ParserRuleContext
        {
            public AssemblyNameContext assemblyName()
            {
                return GetRuleContext<AssemblyNameContext>(0);
            }

            public ITerminalNode[] WS()
            {
                return GetTokens(TypeNamingParser.WS);
            }

            public ITerminalNode WS(int i)
            {
                return GetToken(TypeNamingParser.WS, i);
            }

            public AssemblyVersionContext assemblyVersion()
            {
                return GetRuleContext<AssemblyVersionContext>(0);
            }

            public RegularAssemblyContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_regularAssembly; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterRegularAssembly(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitRegularAssembly(this);
            }
        }

        [RuleVersion(0)]
        public RegularAssemblyContext regularAssembly()
        {
            RegularAssemblyContext _localctx = new RegularAssemblyContext(Context, State);
            EnterRule(_localctx, 52, RULE_regularAssembly);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 235;
                    assemblyName();
                    State = 237;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 236;
                            Match(WS);
                        }
                    }

                    State = 244;
                    _la = TokenStream.La(1);
                    if (_la == T__1)
                    {
                        {
                            State = 239;
                            Match(T__1);
                            State = 241;
                            _la = TokenStream.La(1);
                            if (_la == WS)
                            {
                                {
                                    State = 240;
                                    Match(WS);
                                }
                            }

                            State = 243;
                            assemblyVersion();
                        }
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class AssemblyVersionContext : ParserRuleContext
        {
            public NumContext[] num()
            {
                return GetRuleContexts<NumContext>();
            }

            public NumContext num(int i)
            {
                return GetRuleContext<NumContext>(i);
            }

            public AssemblyVersionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_assemblyVersion; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterAssemblyVersion(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitAssemblyVersion(this);
            }
        }

        [RuleVersion(0)]
        public AssemblyVersionContext assemblyVersion()
        {
            AssemblyVersionContext _localctx = new AssemblyVersionContext(Context, State);
            EnterRule(_localctx, 54, RULE_assemblyVersion);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 246;
                    num();
                    State = 247;
                    Match(T__7);
                    State = 248;
                    num();
                    State = 249;
                    Match(T__7);
                    State = 250;
                    num();
                    State = 251;
                    Match(T__7);
                    State = 252;
                    num();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class AssemblyNameContext : ParserRuleContext
        {
            public IdContext[] id()
            {
                return GetRuleContexts<IdContext>();
            }

            public IdContext id(int i)
            {
                return GetRuleContext<IdContext>(i);
            }

            public AssemblyNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_assemblyName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterAssemblyName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitAssemblyName(this);
            }
        }

        [RuleVersion(0)]
        public AssemblyNameContext assemblyName()
        {
            AssemblyNameContext _localctx = new AssemblyNameContext(Context, State);
            EnterRule(_localctx, 56, RULE_assemblyName);
            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);
                {
                    State = 259;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 18, Context);
                    while (_alt != 2 && _alt != Antlr4.Runtime.Atn.ATN.InvalidAltNumber)
                    {
                        if (_alt == 1)
                        {
                            {
                                {
                                    State = 254;
                                    id();
                                    State = 255;
                                    Match(T__7);
                                }
                            }
                        }
                        State = 261;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 18, Context);
                    }
                    State = 262;
                    id();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class MemberNameContext : ParserRuleContext
        {
            public ITerminalNode UNKNOWN()
            {
                return GetToken(TypeNamingParser.UNKNOWN, 0);
            }

            public SimpleMemberNameContext simpleMemberName()
            {
                return GetRuleContext<SimpleMemberNameContext>(0);
            }

            public PropertyNameContext propertyName()
            {
                return GetRuleContext<PropertyNameContext>(0);
            }

            public MemberNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_memberName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterMemberName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitMemberName(this);
            }
        }

        [RuleVersion(0)]
        public MemberNameContext memberName()
        {
            MemberNameContext _localctx = new MemberNameContext(Context, State);
            EnterRule(_localctx, 58, RULE_memberName);
            try
            {
                State = 267;
                ErrorHandler.Sync(this);
                switch (Interpreter.AdaptivePredict(TokenStream, 19, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);
                    {
                        State = 264;
                        Match(UNKNOWN);
                    }
                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);
                    {
                        State = 265;
                        simpleMemberName();
                    }
                        break;
                    case 3:
                        EnterOuterAlt(_localctx, 3);
                    {
                        State = 266;
                        propertyName();
                    }
                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class SimpleMemberNameContext : ParserRuleContext
        {
            public MethodDefinitionContext methodDefinition()
            {
                return GetRuleContext<MethodDefinitionContext>(0);
            }

            public StaticModifierContext staticModifier()
            {
                return GetRuleContext<StaticModifierContext>(0);
            }

            public ITerminalNode WS()
            {
                return GetToken(TypeNamingParser.WS, 0);
            }

            public SimpleMemberNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_simpleMemberName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterSimpleMemberName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitSimpleMemberName(this);
            }
        }

        [RuleVersion(0)]
        public SimpleMemberNameContext simpleMemberName()
        {
            SimpleMemberNameContext _localctx = new SimpleMemberNameContext(Context, State);
            EnterRule(_localctx, 60, RULE_simpleMemberName);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 270;
                    _la = TokenStream.La(1);
                    if (_la == T__21)
                    {
                        {
                            State = 269;
                            staticModifier();
                        }
                    }

                    State = 273;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 272;
                            Match(WS);
                        }
                    }

                    State = 275;
                    methodDefinition();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class PropertyNameContext : ParserRuleContext
        {
            public MethodDefinitionContext methodDefinition()
            {
                return GetRuleContext<MethodDefinitionContext>(0);
            }

            public StaticModifierContext staticModifier()
            {
                return GetRuleContext<StaticModifierContext>(0);
            }

            public PropertyModifierContext propertyModifier()
            {
                return GetRuleContext<PropertyModifierContext>(0);
            }

            public ITerminalNode WS()
            {
                return GetToken(TypeNamingParser.WS, 0);
            }

            public MethodSignatureContext methodSignature()
            {
                return GetRuleContext<MethodSignatureContext>(0);
            }

            public PropertyNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_propertyName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterPropertyName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitPropertyName(this);
            }
        }

        [RuleVersion(0)]
        public PropertyNameContext propertyName()
        {
            PropertyNameContext _localctx = new PropertyNameContext(Context, State);
            EnterRule(_localctx, 62, RULE_propertyName);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 279;
                    switch (TokenStream.La(1))
                    {
                        case T__21:
                        {
                            State = 277;
                            staticModifier();
                        }
                            break;
                        case T__14:
                        case T__15:
                        {
                            State = 278;
                            propertyModifier();
                        }
                            break;
                        case T__12:
                        case WS:
                            break;
                        default:
                            throw new NoViableAltException(this);
                    }
                    State = 282;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 281;
                            Match(WS);
                        }
                    }

                    State = 284;
                    methodDefinition();
                    State = 286;
                    _la = TokenStream.La(1);
                    if (_la == T__16)
                    {
                        {
                            State = 285;
                            methodSignature();
                        }
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class PropertyModifierContext : ParserRuleContext
        {
            public BothPropertyModifiersContext bothPropertyModifiers()
            {
                return GetRuleContext<BothPropertyModifiersContext>(0);
            }

            public PropertyModifierContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_propertyModifier; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterPropertyModifier(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitPropertyModifier(this);
            }
        }

        [RuleVersion(0)]
        public PropertyModifierContext propertyModifier()
        {
            PropertyModifierContext _localctx = new PropertyModifierContext(Context, State);
            EnterRule(_localctx, 64, RULE_propertyModifier);
            try
            {
                State = 291;
                ErrorHandler.Sync(this);
                switch (Interpreter.AdaptivePredict(TokenStream, 25, Context))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);
                    {
                        State = 288;
                        Match(T__14);
                    }
                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2);
                    {
                        State = 289;
                        Match(T__15);
                    }
                        break;
                    case 3:
                        EnterOuterAlt(_localctx, 3);
                    {
                        State = 290;
                        bothPropertyModifiers();
                    }
                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class BothPropertyModifiersContext : ParserRuleContext
        {
            public ITerminalNode WS()
            {
                return GetToken(TypeNamingParser.WS, 0);
            }

            public BothPropertyModifiersContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_bothPropertyModifiers; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterBothPropertyModifiers(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitBothPropertyModifiers(this);
            }
        }

        [RuleVersion(0)]
        public BothPropertyModifiersContext bothPropertyModifiers()
        {
            BothPropertyModifiersContext _localctx = new BothPropertyModifiersContext(Context, State);
            EnterRule(_localctx, 66, RULE_bothPropertyModifiers);
            int _la;
            try
            {
                State = 303;
                switch (TokenStream.La(1))
                {
                    case T__14:
                        EnterOuterAlt(_localctx, 1);
                    {
                        {
                            State = 293;
                            Match(T__14);
                            State = 295;
                            _la = TokenStream.La(1);
                            if (_la == WS)
                            {
                                {
                                    State = 294;
                                    Match(WS);
                                }
                            }

                            State = 297;
                            Match(T__15);
                        }
                    }
                        break;
                    case T__15:
                        EnterOuterAlt(_localctx, 2);
                    {
                        {
                            State = 298;
                            Match(T__15);
                            State = 300;
                            _la = TokenStream.La(1);
                            if (_la == WS)
                            {
                                {
                                    State = 299;
                                    Match(WS);
                                }
                            }

                            State = 302;
                            Match(T__14);
                        }
                    }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class LambdaNameContext : ParserRuleContext
        {
            public ITerminalNode UNKNOWN()
            {
                return GetToken(TypeNamingParser.UNKNOWN, 0);
            }

            public RealLambdaNameContext realLambdaName()
            {
                return GetRuleContext<RealLambdaNameContext>(0);
            }

            public LambdaNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_lambdaName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterLambdaName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitLambdaName(this);
            }
        }

        [RuleVersion(0)]
        public LambdaNameContext lambdaName()
        {
            LambdaNameContext _localctx = new LambdaNameContext(Context, State);
            EnterRule(_localctx, 68, RULE_lambdaName);
            try
            {
                State = 307;
                switch (TokenStream.La(1))
                {
                    case UNKNOWN:
                        EnterOuterAlt(_localctx, 1);
                    {
                        State = 305;
                        Match(UNKNOWN);
                    }
                        break;
                    case T__12:
                        EnterOuterAlt(_localctx, 2);
                    {
                        State = 306;
                        realLambdaName();
                    }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class RealLambdaNameContext : ParserRuleContext
        {
            public TypeContext type()
            {
                return GetRuleContext<TypeContext>(0);
            }

            public MethodSignatureContext methodSignature()
            {
                return GetRuleContext<MethodSignatureContext>(0);
            }

            public ITerminalNode WS()
            {
                return GetToken(TypeNamingParser.WS, 0);
            }

            public RealLambdaNameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_realLambdaName; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterRealLambdaName(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitRealLambdaName(this);
            }
        }

        [RuleVersion(0)]
        public RealLambdaNameContext realLambdaName()
        {
            RealLambdaNameContext _localctx = new RealLambdaNameContext(Context, State);
            EnterRule(_localctx, 70, RULE_realLambdaName);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 309;
                    Match(T__12);
                    State = 310;
                    type();
                    State = 311;
                    Match(T__13);
                    State = 313;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 312;
                            Match(WS);
                        }
                    }

                    State = 315;
                    methodSignature();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class MethodContext : ParserRuleContext
        {
            public ITerminalNode UNKNOWN()
            {
                return GetToken(TypeNamingParser.UNKNOWN, 0);
            }

            public RegularMethodContext regularMethod()
            {
                return GetRuleContext<RegularMethodContext>(0);
            }

            public MethodContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_method; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterMethod(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitMethod(this);
            }
        }

        [RuleVersion(0)]
        public MethodContext method()
        {
            MethodContext _localctx = new MethodContext(Context, State);
            EnterRule(_localctx, 72, RULE_method);
            try
            {
                State = 319;
                switch (TokenStream.La(1))
                {
                    case UNKNOWN:
                        EnterOuterAlt(_localctx, 1);
                    {
                        State = 317;
                        Match(UNKNOWN);
                    }
                        break;
                    case T__12:
                    case T__21:
                    case WS:
                        EnterOuterAlt(_localctx, 2);
                    {
                        State = 318;
                        regularMethod();
                    }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class RegularMethodContext : ParserRuleContext
        {
            public MethodSignatureContext methodSignature()
            {
                return GetRuleContext<MethodSignatureContext>(0);
            }

            public NonStaticCtorContext nonStaticCtor()
            {
                return GetRuleContext<NonStaticCtorContext>(0);
            }

            public StaticCctorContext staticCctor()
            {
                return GetRuleContext<StaticCctorContext>(0);
            }

            public CustomMethodContext customMethod()
            {
                return GetRuleContext<CustomMethodContext>(0);
            }

            public RegularMethodContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_regularMethod; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterRegularMethod(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitRegularMethod(this);
            }
        }

        [RuleVersion(0)]
        public RegularMethodContext regularMethod()
        {
            RegularMethodContext _localctx = new RegularMethodContext(Context, State);
            EnterRule(_localctx, 74, RULE_regularMethod);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 324;
                    ErrorHandler.Sync(this);
                    switch (Interpreter.AdaptivePredict(TokenStream, 32, Context))
                    {
                        case 1:
                        {
                            State = 321;
                            nonStaticCtor();
                        }
                            break;
                        case 2:
                        {
                            State = 322;
                            staticCctor();
                        }
                            break;
                        case 3:
                        {
                            State = 323;
                            customMethod();
                        }
                            break;
                    }
                    State = 326;
                    methodSignature();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class MethodSignatureContext : ParserRuleContext
        {
            public ITerminalNode[] WS()
            {
                return GetTokens(TypeNamingParser.WS);
            }

            public ITerminalNode WS(int i)
            {
                return GetToken(TypeNamingParser.WS, i);
            }

            public FormalParamContext[] formalParam()
            {
                return GetRuleContexts<FormalParamContext>();
            }

            public FormalParamContext formalParam(int i)
            {
                return GetRuleContext<FormalParamContext>(i);
            }

            public MethodSignatureContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_methodSignature; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterMethodSignature(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitMethodSignature(this);
            }
        }

        [RuleVersion(0)]
        public MethodSignatureContext methodSignature()
        {
            MethodSignatureContext _localctx = new MethodSignatureContext(Context, State);
            EnterRule(_localctx, 76, RULE_methodSignature);
            int _la;
            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);
                {
                    State = 328;
                    Match(T__16);
                    State = 330;
                    ErrorHandler.Sync(this);
                    switch (Interpreter.AdaptivePredict(TokenStream, 33, Context))
                    {
                        case 1:
                        {
                            State = 329;
                            Match(WS);
                        }
                            break;
                    }
                    State = 346;
                    ErrorHandler.Sync(this);
                    switch (Interpreter.AdaptivePredict(TokenStream, 37, Context))
                    {
                        case 1:
                        {
                            State = 332;
                            formalParam();
                            State = 343;
                            ErrorHandler.Sync(this);
                            _alt = Interpreter.AdaptivePredict(TokenStream, 36, Context);
                            while (_alt != 2 && _alt != Antlr4.Runtime.Atn.ATN.InvalidAltNumber)
                            {
                                if (_alt == 1)
                                {
                                    {
                                        {
                                            State = 334;
                                            _la = TokenStream.La(1);
                                            if (_la == WS)
                                            {
                                                {
                                                    State = 333;
                                                    Match(WS);
                                                }
                                            }

                                            State = 336;
                                            Match(T__1);
                                            State = 338;
                                            ErrorHandler.Sync(this);
                                            switch (Interpreter.AdaptivePredict(TokenStream, 35, Context))
                                            {
                                                case 1:
                                                {
                                                    State = 337;
                                                    Match(WS);
                                                }
                                                    break;
                                            }
                                            State = 340;
                                            formalParam();
                                        }
                                    }
                                }
                                State = 345;
                                ErrorHandler.Sync(this);
                                _alt = Interpreter.AdaptivePredict(TokenStream, 36, Context);
                            }
                        }
                            break;
                    }
                    State = 349;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 348;
                            Match(WS);
                        }
                    }

                    State = 351;
                    Match(T__17);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class NonStaticCtorContext : ParserRuleContext
        {
            public ITerminalNode UNKNOWN()
            {
                return GetToken(TypeNamingParser.UNKNOWN, 0);
            }

            public TypeContext type()
            {
                return GetRuleContext<TypeContext>(0);
            }

            public ITerminalNode[] WS()
            {
                return GetTokens(TypeNamingParser.WS);
            }

            public ITerminalNode WS(int i)
            {
                return GetToken(TypeNamingParser.WS, i);
            }

            public NonStaticCtorContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_nonStaticCtor; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterNonStaticCtor(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitNonStaticCtor(this);
            }
        }

        [RuleVersion(0)]
        public NonStaticCtorContext nonStaticCtor()
        {
            NonStaticCtorContext _localctx = new NonStaticCtorContext(Context, State);
            EnterRule(_localctx, 78, RULE_nonStaticCtor);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 354;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 353;
                            Match(WS);
                        }
                    }

                    State = 356;
                    Match(T__12);
                    State = 357;
                    Match(UNKNOWN);
                    State = 358;
                    Match(T__13);
                    State = 360;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 359;
                            Match(WS);
                        }
                    }

                    State = 362;
                    Match(T__12);
                    State = 363;
                    type();
                    State = 364;
                    Match(T__18);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class StaticCctorContext : ParserRuleContext
        {
            public StaticModifierContext staticModifier()
            {
                return GetRuleContext<StaticModifierContext>(0);
            }

            public ITerminalNode UNKNOWN()
            {
                return GetToken(TypeNamingParser.UNKNOWN, 0);
            }

            public TypeContext type()
            {
                return GetRuleContext<TypeContext>(0);
            }

            public ITerminalNode[] WS()
            {
                return GetTokens(TypeNamingParser.WS);
            }

            public ITerminalNode WS(int i)
            {
                return GetToken(TypeNamingParser.WS, i);
            }

            public StaticCctorContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_staticCctor; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterStaticCctor(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitStaticCctor(this);
            }
        }

        [RuleVersion(0)]
        public StaticCctorContext staticCctor()
        {
            StaticCctorContext _localctx = new StaticCctorContext(Context, State);
            EnterRule(_localctx, 80, RULE_staticCctor);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 366;
                    staticModifier();
                    State = 368;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 367;
                            Match(WS);
                        }
                    }

                    State = 370;
                    Match(T__12);
                    State = 371;
                    Match(UNKNOWN);
                    State = 372;
                    Match(T__13);
                    State = 374;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 373;
                            Match(WS);
                        }
                    }

                    State = 376;
                    Match(T__12);
                    State = 377;
                    type();
                    State = 378;
                    Match(T__19);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class CustomMethodContext : ParserRuleContext
        {
            public MethodDefinitionContext methodDefinition()
            {
                return GetRuleContext<MethodDefinitionContext>(0);
            }

            public StaticModifierContext staticModifier()
            {
                return GetRuleContext<StaticModifierContext>(0);
            }

            public ITerminalNode WS()
            {
                return GetToken(TypeNamingParser.WS, 0);
            }

            public GenericTypePartContext genericTypePart()
            {
                return GetRuleContext<GenericTypePartContext>(0);
            }

            public CustomMethodContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_customMethod; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterCustomMethod(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitCustomMethod(this);
            }
        }

        [RuleVersion(0)]
        public CustomMethodContext customMethod()
        {
            CustomMethodContext _localctx = new CustomMethodContext(Context, State);
            EnterRule(_localctx, 82, RULE_customMethod);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 381;
                    _la = TokenStream.La(1);
                    if (_la == T__21)
                    {
                        {
                            State = 380;
                            staticModifier();
                        }
                    }

                    State = 384;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 383;
                            Match(WS);
                        }
                    }

                    State = 386;
                    methodDefinition();
                    State = 388;
                    _la = TokenStream.La(1);
                    if (_la == T__11)
                    {
                        {
                            State = 387;
                            genericTypePart();
                        }
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class MethodDefinitionContext : ParserRuleContext
        {
            public TypeContext[] type()
            {
                return GetRuleContexts<TypeContext>();
            }

            public TypeContext type(int i)
            {
                return GetRuleContext<TypeContext>(i);
            }

            public IdContext id()
            {
                return GetRuleContext<IdContext>(0);
            }

            public ITerminalNode WS()
            {
                return GetToken(TypeNamingParser.WS, 0);
            }

            public MethodDefinitionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_methodDefinition; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterMethodDefinition(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitMethodDefinition(this);
            }
        }

        [RuleVersion(0)]
        public MethodDefinitionContext methodDefinition()
        {
            MethodDefinitionContext _localctx = new MethodDefinitionContext(Context, State);
            EnterRule(_localctx, 84, RULE_methodDefinition);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 390;
                    Match(T__12);
                    State = 391;
                    type();
                    State = 392;
                    Match(T__13);
                    State = 394;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 393;
                            Match(WS);
                        }
                    }

                    State = 396;
                    Match(T__12);
                    State = 397;
                    type();
                    State = 398;
                    Match(T__20);
                    State = 399;
                    id();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class FormalParamContext : ParserRuleContext
        {
            public TypeContext type()
            {
                return GetRuleContext<TypeContext>(0);
            }

            public IdContext id()
            {
                return GetRuleContext<IdContext>(0);
            }

            public ParameterModifierContext parameterModifier()
            {
                return GetRuleContext<ParameterModifierContext>(0);
            }

            public ITerminalNode[] WS()
            {
                return GetTokens(TypeNamingParser.WS);
            }

            public ITerminalNode WS(int i)
            {
                return GetToken(TypeNamingParser.WS, i);
            }

            public FormalParamContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_formalParam; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterFormalParam(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitFormalParam(this);
            }
        }

        [RuleVersion(0)]
        public FormalParamContext formalParam()
        {
            FormalParamContext _localctx = new FormalParamContext(Context, State);
            EnterRule(_localctx, 86, RULE_formalParam);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 405;
                    ErrorHandler.Sync(this);
                    switch (Interpreter.AdaptivePredict(TokenStream, 48, Context))
                    {
                        case 1:
                        {
                            State = 402;
                            _la = TokenStream.La(1);
                            if (_la == WS)
                            {
                                {
                                    State = 401;
                                    Match(WS);
                                }
                            }

                            State = 404;
                            parameterModifier();
                        }
                            break;
                    }
                    State = 408;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 407;
                            Match(WS);
                        }
                    }

                    State = 410;
                    Match(T__12);
                    State = 411;
                    type();
                    State = 412;
                    Match(T__13);
                    State = 414;
                    _la = TokenStream.La(1);
                    if (_la == WS)
                    {
                        {
                            State = 413;
                            Match(WS);
                        }
                    }

                    State = 416;
                    id();
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class ParameterModifierContext : ParserRuleContext
        {
            public ParamsModifierContext paramsModifier()
            {
                return GetRuleContext<ParamsModifierContext>(0);
            }

            public OptsModifierContext optsModifier()
            {
                return GetRuleContext<OptsModifierContext>(0);
            }

            public RefModifierContext refModifier()
            {
                return GetRuleContext<RefModifierContext>(0);
            }

            public OutModifierContext outModifier()
            {
                return GetRuleContext<OutModifierContext>(0);
            }

            public ExtensionModifierContext extensionModifier()
            {
                return GetRuleContext<ExtensionModifierContext>(0);
            }

            public ParameterModifierContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_parameterModifier; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterParameterModifier(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitParameterModifier(this);
            }
        }

        [RuleVersion(0)]
        public ParameterModifierContext parameterModifier()
        {
            ParameterModifierContext _localctx = new ParameterModifierContext(Context, State);
            EnterRule(_localctx, 88, RULE_parameterModifier);
            try
            {
                State = 423;
                switch (TokenStream.La(1))
                {
                    case T__22:
                        EnterOuterAlt(_localctx, 1);
                    {
                        State = 418;
                        paramsModifier();
                    }
                        break;
                    case T__23:
                        EnterOuterAlt(_localctx, 2);
                    {
                        State = 419;
                        optsModifier();
                    }
                        break;
                    case T__24:
                        EnterOuterAlt(_localctx, 3);
                    {
                        State = 420;
                        refModifier();
                    }
                        break;
                    case T__25:
                        EnterOuterAlt(_localctx, 4);
                    {
                        State = 421;
                        outModifier();
                    }
                        break;
                    case T__26:
                        EnterOuterAlt(_localctx, 5);
                    {
                        State = 422;
                        extensionModifier();
                    }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class StaticModifierContext : ParserRuleContext
        {
            public StaticModifierContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_staticModifier; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterStaticModifier(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitStaticModifier(this);
            }
        }

        [RuleVersion(0)]
        public StaticModifierContext staticModifier()
        {
            StaticModifierContext _localctx = new StaticModifierContext(Context, State);
            EnterRule(_localctx, 90, RULE_staticModifier);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 425;
                    Match(T__21);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class ParamsModifierContext : ParserRuleContext
        {
            public ParamsModifierContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_paramsModifier; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterParamsModifier(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitParamsModifier(this);
            }
        }

        [RuleVersion(0)]
        public ParamsModifierContext paramsModifier()
        {
            ParamsModifierContext _localctx = new ParamsModifierContext(Context, State);
            EnterRule(_localctx, 92, RULE_paramsModifier);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 427;
                    Match(T__22);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class OptsModifierContext : ParserRuleContext
        {
            public OptsModifierContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_optsModifier; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterOptsModifier(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitOptsModifier(this);
            }
        }

        [RuleVersion(0)]
        public OptsModifierContext optsModifier()
        {
            OptsModifierContext _localctx = new OptsModifierContext(Context, State);
            EnterRule(_localctx, 94, RULE_optsModifier);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 429;
                    Match(T__23);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class RefModifierContext : ParserRuleContext
        {
            public RefModifierContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_refModifier; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterRefModifier(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitRefModifier(this);
            }
        }

        [RuleVersion(0)]
        public RefModifierContext refModifier()
        {
            RefModifierContext _localctx = new RefModifierContext(Context, State);
            EnterRule(_localctx, 96, RULE_refModifier);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 431;
                    Match(T__24);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class OutModifierContext : ParserRuleContext
        {
            public OutModifierContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_outModifier; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterOutModifier(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitOutModifier(this);
            }
        }

        [RuleVersion(0)]
        public OutModifierContext outModifier()
        {
            OutModifierContext _localctx = new OutModifierContext(Context, State);
            EnterRule(_localctx, 98, RULE_outModifier);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 433;
                    Match(T__25);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class ExtensionModifierContext : ParserRuleContext
        {
            public ExtensionModifierContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_extensionModifier; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterExtensionModifier(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitExtensionModifier(this);
            }
        }

        [RuleVersion(0)]
        public ExtensionModifierContext extensionModifier()
        {
            ExtensionModifierContext _localctx = new ExtensionModifierContext(Context, State);
            EnterRule(_localctx, 100, RULE_extensionModifier);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 435;
                    Match(T__26);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class IdContext : ParserRuleContext
        {
            public ITerminalNode[] LETTER()
            {
                return GetTokens(TypeNamingParser.LETTER);
            }

            public ITerminalNode LETTER(int i)
            {
                return GetToken(TypeNamingParser.LETTER, i);
            }

            public NumContext[] num()
            {
                return GetRuleContexts<NumContext>();
            }

            public NumContext num(int i)
            {
                return GetRuleContext<NumContext>(i);
            }

            public ITerminalNode[] SIGN()
            {
                return GetTokens(TypeNamingParser.SIGN);
            }

            public ITerminalNode SIGN(int i)
            {
                return GetToken(TypeNamingParser.SIGN, i);
            }

            public IdContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_id; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterId(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitId(this);
            }
        }

        [RuleVersion(0)]
        public IdContext id()
        {
            IdContext _localctx = new IdContext(Context, State);
            EnterRule(_localctx, 102, RULE_id);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 437;
                    Match(LETTER);
                    State = 443;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.La(1);
                    while ((((_la) & ~0x3f) == 0 &&
                            ((1L << _la) & ((1L << T__27) | (1L << POSNUM) | (1L << LETTER) | (1L << SIGN))) != 0))
                    {
                        {
                            State = 441;
                            switch (TokenStream.La(1))
                            {
                                case LETTER:
                                {
                                    State = 438;
                                    Match(LETTER);
                                }
                                    break;
                                case T__27:
                                case POSNUM:
                                {
                                    State = 439;
                                    num();
                                }
                                    break;
                                case SIGN:
                                {
                                    State = 440;
                                    Match(SIGN);
                                }
                                    break;
                                default:
                                    throw new NoViableAltException(this);
                            }
                        }
                        State = 445;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.La(1);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public class NumContext : ParserRuleContext
        {
            public ITerminalNode POSNUM()
            {
                return GetToken(TypeNamingParser.POSNUM, 0);
            }

            public NumContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState) {}

            public override int RuleIndex
            {
                get { return RULE_num; }
            }

            public override void EnterRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.EnterNum(this);
            }

            public override void ExitRule(IParseTreeListener listener)
            {
                ITypeNamingListener typedListener = listener as ITypeNamingListener;
                if (typedListener != null) typedListener.ExitNum(this);
            }
        }

        [RuleVersion(0)]
        public NumContext num()
        {
            NumContext _localctx = new NumContext(Context, State);
            EnterRule(_localctx, 104, RULE_num);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 446;
                    _la = TokenStream.La(1);
                    if (!(_la == T__27 || _la == POSNUM))
                    {
                        ErrorHandler.RecoverInline(this);
                    }
                    else
                    {
                        Consume();
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        private static readonly string _serializedATN = _serializeATN();

        private static string _serializeATN()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3$\x1C3");
            sb.Append("\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a");
            sb.Append("\t\a\x4\b\t\b\x4\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4");
            sb.Append("\xE\t\xE\x4\xF\t\xF\x4\x10\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4");
            sb.Append("\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15\x4\x16\t\x16\x4\x17\t\x17");
            sb.Append("\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B\t\x1B\x4\x1C");
            sb.Append("\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!\t!");
            sb.Append("\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t");
            sb.Append(")\x4*\t*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4");
            sb.Append("\x31\t\x31\x4\x32\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4\x35\t\x35");
            sb.Append("\x4\x36\t\x36\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x3\x4\x3\x4");
            sb.Append("\x3\x4\x3\x5\x3\x5\x3\x5\x3\x6\x3\x6\x3\x6\x3\a\x3\a\x3\a\x3");
            sb.Append("\b\x3\b\x3\b\x3\t\x3\t\x3\t\x3\t\x3\t\x5\t\x87\n\t\x3\n\x3\n");
            sb.Append("\x5\n\x8B\n\n\x3\n\x3\n\x5\n\x8F\n\n\x3\n\x5\n\x92\n\n\x3\v");
            sb.Append("\x3\v\x3\v\x3\v\x3\v\x5\v\x99\n\v\x3\f\x3\f\x5\f\x9D\n\f\x3");
            sb.Append("\f\x3\f\x5\f\xA1\n\f\x3\f\x3\f\x3\r\x3\r\x3\r\x3\xE\x3\xE\x3");
            sb.Append("\xE\x3\xE\x3\xE\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\x10\x3\x10");
            sb.Append("\x5\x10\xB4\n\x10\x3\x11\x5\x11\xB7\n\x11\x3\x11\x3\x11\x3\x12");
            sb.Append("\x3\x12\x3\x12\x6\x12\xBE\n\x12\r\x12\xE\x12\xBF\x3\x13\x3\x13");
            sb.Append("\x5\x13\xC4\n\x13\x3\x14\x3\x14\x3\x14\x5\x14\xC9\n\x14\x3\x14");
            sb.Append("\x5\x14\xCC\n\x14\x3\x15\x3\x15\x3\x15\x3\x16\x3\x16\x3\x16");
            sb.Append("\x3\x17\x3\x17\x3\x17\x3\x18\x3\x18\x3\x19\x3\x19\x3\x19\x3");
            sb.Append("\x19\x3\x19\x3\x19\a\x19\xDF\n\x19\f\x19\xE\x19\xE2\v\x19\x3");
            sb.Append("\x19\x3\x19\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1B\x3\x1B\x5\x1B");
            sb.Append("\xEC\n\x1B\x3\x1C\x3\x1C\x5\x1C\xF0\n\x1C\x3\x1C\x3\x1C\x5\x1C");
            sb.Append("\xF4\n\x1C\x3\x1C\x5\x1C\xF7\n\x1C\x3\x1D\x3\x1D\x3\x1D\x3\x1D");
            sb.Append("\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1E\x3\x1E\x3\x1E\a\x1E\x104");
            sb.Append("\n\x1E\f\x1E\xE\x1E\x107\v\x1E\x3\x1E\x3\x1E\x3\x1F\x3\x1F\x3");
            sb.Append("\x1F\x5\x1F\x10E\n\x1F\x3 \x5 \x111\n \x3 \x5 \x114\n \x3 \x3");
            sb.Append(" \x3!\x3!\x5!\x11A\n!\x3!\x5!\x11D\n!\x3!\x3!\x5!\x121\n!\x3");
            sb.Append("\"\x3\"\x3\"\x5\"\x126\n\"\x3#\x3#\x5#\x12A\n#\x3#\x3#\x3#\x5");
            sb.Append("#\x12F\n#\x3#\x5#\x132\n#\x3$\x3$\x5$\x136\n$\x3%\x3%\x3%\x3");
            sb.Append("%\x5%\x13C\n%\x3%\x3%\x3&\x3&\x5&\x142\n&\x3\'\x3\'\x3\'\x5");
            sb.Append("\'\x147\n\'\x3\'\x3\'\x3(\x3(\x5(\x14D\n(\x3(\x3(\x5(\x151\n");
            sb.Append("(\x3(\x3(\x5(\x155\n(\x3(\a(\x158\n(\f(\xE(\x15B\v(\x5(\x15D");
            sb.Append("\n(\x3(\x5(\x160\n(\x3(\x3(\x3)\x5)\x165\n)\x3)\x3)\x3)\x3)");
            sb.Append("\x5)\x16B\n)\x3)\x3)\x3)\x3)\x3*\x3*\x5*\x173\n*\x3*\x3*\x3");
            sb.Append("*\x3*\x5*\x179\n*\x3*\x3*\x3*\x3*\x3+\x5+\x180\n+\x3+\x5+\x183");
            sb.Append("\n+\x3+\x3+\x5+\x187\n+\x3,\x3,\x3,\x3,\x5,\x18D\n,\x3,\x3,");
            sb.Append("\x3,\x3,\x3,\x3-\x5-\x195\n-\x3-\x5-\x198\n-\x3-\x5-\x19B\n");
            sb.Append("-\x3-\x3-\x3-\x3-\x5-\x1A1\n-\x3-\x3-\x3.\x3.\x3.\x3.\x3.\x5");
            sb.Append(".\x1AA\n.\x3/\x3/\x3\x30\x3\x30\x3\x31\x3\x31\x3\x32\x3\x32");
            sb.Append("\x3\x33\x3\x33\x3\x34\x3\x34\x3\x35\x3\x35\x3\x35\x3\x35\a\x35");
            sb.Append("\x1BC\n\x35\f\x35\xE\x35\x1BF\v\x35\x3\x36\x3\x36\x3\x36\x2");
            sb.Append("\x2\x37\x2\x4\x6\b\n\f\xE\x10\x12\x14\x16\x18\x1A\x1C\x1E \"");
            sb.Append("$&(*,.\x30\x32\x34\x36\x38:<>@\x42\x44\x46HJLNPRTVXZ\\^`\x62");
            sb.Append("\x64\x66hj\x2\x3\x4\x2\x1E\x1E  \x1D2\x2l\x3\x2\x2\x2\x4o\x3");
            sb.Append("\x2\x2\x2\x6r\x3\x2\x2\x2\bu\x3\x2\x2\x2\nx\x3\x2\x2\x2\f{\x3");
            sb.Append("\x2\x2\x2\xE~\x3\x2\x2\x2\x10\x86\x3\x2\x2\x2\x12\x88\x3\x2");
            sb.Append("\x2\x2\x14\x98\x3\x2\x2\x2\x16\x9C\x3\x2\x2\x2\x18\xA4\x3\x2");
            sb.Append("\x2\x2\x1A\xA7\x3\x2\x2\x2\x1C\xAC\x3\x2\x2\x2\x1E\xB3\x3\x2");
            sb.Append("\x2\x2 \xB6\x3\x2\x2\x2\"\xBD\x3\x2\x2\x2$\xC3\x3\x2\x2\x2&");
            sb.Append("\xC8\x3\x2\x2\x2(\xCD\x3\x2\x2\x2*\xD0\x3\x2\x2\x2,\xD3\x3\x2");
            sb.Append("\x2\x2.\xD6\x3\x2\x2\x2\x30\xD8\x3\x2\x2\x2\x32\xE5\x3\x2\x2");
            sb.Append("\x2\x34\xEB\x3\x2\x2\x2\x36\xED\x3\x2\x2\x2\x38\xF8\x3\x2\x2");
            sb.Append("\x2:\x105\x3\x2\x2\x2<\x10D\x3\x2\x2\x2>\x110\x3\x2\x2\x2@\x119");
            sb.Append("\x3\x2\x2\x2\x42\x125\x3\x2\x2\x2\x44\x131\x3\x2\x2\x2\x46\x135");
            sb.Append("\x3\x2\x2\x2H\x137\x3\x2\x2\x2J\x141\x3\x2\x2\x2L\x146\x3\x2");
            sb.Append("\x2\x2N\x14A\x3\x2\x2\x2P\x164\x3\x2\x2\x2R\x170\x3\x2\x2\x2");
            sb.Append("T\x17F\x3\x2\x2\x2V\x188\x3\x2\x2\x2X\x197\x3\x2\x2\x2Z\x1A9");
            sb.Append("\x3\x2\x2\x2\\\x1AB\x3\x2\x2\x2^\x1AD\x3\x2\x2\x2`\x1AF\x3\x2");
            sb.Append("\x2\x2\x62\x1B1\x3\x2\x2\x2\x64\x1B3\x3\x2\x2\x2\x66\x1B5\x3");
            sb.Append("\x2\x2\x2h\x1B7\x3\x2\x2\x2j\x1C0\x3\x2\x2\x2lm\x5\x10\t\x2");
            sb.Append("mn\a$\x2\x2n\x3\x3\x2\x2\x2op\x5J&\x2pq\a$\x2\x2q\x5\x3\x2\x2");
            sb.Append("\x2rs\x5\"\x12\x2st\a$\x2\x2t\a\x3\x2\x2\x2uv\x5\x34\x1B\x2");
            sb.Append("vw\a$\x2\x2w\t\x3\x2\x2\x2xy\x5X-\x2yz\a$\x2\x2z\v\x3\x2\x2");
            sb.Append("\x2{|\x5<\x1F\x2|}\a$\x2\x2}\r\x3\x2\x2\x2~\x7F\x5\x46$\x2\x7F");
            sb.Append("\x80\a$\x2\x2\x80\xF\x3\x2\x2\x2\x81\x87\a\x1F\x2\x2\x82\x87");
            sb.Append("\x5\x12\n\x2\x83\x87\x5\x16\f\x2\x84\x87\x5\x18\r\x2\x85\x87");
            sb.Append("\x5\x1A\xE\x2\x86\x81\x3\x2\x2\x2\x86\x82\x3\x2\x2\x2\x86\x83");
            sb.Append("\x3\x2\x2\x2\x86\x84\x3\x2\x2\x2\x86\x85\x3\x2\x2\x2\x87\x11");
            sb.Append("\x3\x2\x2\x2\x88\x91\x5h\x35\x2\x89\x8B\a#\x2\x2\x8A\x89\x3");
            sb.Append("\x2\x2\x2\x8A\x8B\x3\x2\x2\x2\x8B\x8C\x3\x2\x2\x2\x8C\x8E\a");
            sb.Append("\x3\x2\x2\x8D\x8F\a#\x2\x2\x8E\x8D\x3\x2\x2\x2\x8E\x8F\x3\x2");
            sb.Append("\x2\x2\x8F\x90\x3\x2\x2\x2\x90\x92\x5\x14\v\x2\x91\x8A\x3\x2");
            sb.Append("\x2\x2\x91\x92\x3\x2\x2\x2\x92\x13\x3\x2\x2\x2\x93\x99\x5\x16");
            sb.Append("\f\x2\x94\x99\x5\x18\r\x2\x95\x99\x5\x1A\xE\x2\x96\x99\a\x1F");
            sb.Append("\x2\x2\x97\x99\x5h\x35\x2\x98\x93\x3\x2\x2\x2\x98\x94\x3\x2");
            sb.Append("\x2\x2\x98\x95\x3\x2\x2\x2\x98\x96\x3\x2\x2\x2\x98\x97\x3\x2");
            sb.Append("\x2\x2\x99\x15\x3\x2\x2\x2\x9A\x9D\x5 \x11\x2\x9B\x9D\x5\x1C");
            sb.Append("\xF\x2\x9C\x9A\x3\x2\x2\x2\x9C\x9B\x3\x2\x2\x2\x9D\x9E\x3\x2");
            sb.Append("\x2\x2\x9E\xA0\a\x4\x2\x2\x9F\xA1\a#\x2\x2\xA0\x9F\x3\x2\x2");
            sb.Append("\x2\xA0\xA1\x3\x2\x2\x2\xA1\xA2\x3\x2\x2\x2\xA2\xA3\x5\x34\x1B");
            sb.Append("\x2\xA3\x17\x3\x2\x2\x2\xA4\xA5\a\x5\x2\x2\xA5\xA6\x5J&\x2\xA6");
            sb.Append("\x19\x3\x2\x2\x2\xA7\xA8\a\x6\x2\x2\xA8\xA9\a \x2\x2\xA9\xAA");
            sb.Append("\a\a\x2\x2\xAA\xAB\x5\x10\t\x2\xAB\x1B\x3\x2\x2\x2\xAC\xAD\a");
            sb.Append("\b\x2\x2\xAD\xAE\x5\x1E\x10\x2\xAE\xAF\a\t\x2\x2\xAF\xB0\x5");
            sb.Append("$\x13\x2\xB0\x1D\x3\x2\x2\x2\xB1\xB4\x5\x1C\xF\x2\xB2\xB4\x5");
            sb.Append(" \x11\x2\xB3\xB1\x3\x2\x2\x2\xB3\xB2\x3\x2\x2\x2\xB4\x1F\x3");
            sb.Append("\x2\x2\x2\xB5\xB7\x5\"\x12\x2\xB6\xB5\x3\x2\x2\x2\xB6\xB7\x3");
            sb.Append("\x2\x2\x2\xB7\xB8\x3\x2\x2\x2\xB8\xB9\x5$\x13\x2\xB9!\x3\x2");
            sb.Append("\x2\x2\xBA\xBB\x5h\x35\x2\xBB\xBC\a\n\x2\x2\xBC\xBE\x3\x2\x2");
            sb.Append("\x2\xBD\xBA\x3\x2\x2\x2\xBE\xBF\x3\x2\x2\x2\xBF\xBD\x3\x2\x2");
            sb.Append("\x2\xBF\xC0\x3\x2\x2\x2\xC0#\x3\x2\x2\x2\xC1\xC4\x5(\x15\x2");
            sb.Append("\xC2\xC4\x5&\x14\x2\xC3\xC1\x3\x2\x2\x2\xC3\xC2\x3\x2\x2\x2");
            sb.Append("\xC4%\x3\x2\x2\x2\xC5\xC9\x5*\x16\x2\xC6\xC9\x5,\x17\x2\xC7");
            sb.Append("\xC9\x5.\x18\x2\xC8\xC5\x3\x2\x2\x2\xC8\xC6\x3\x2\x2\x2\xC8");
            sb.Append("\xC7\x3\x2\x2\x2\xC9\xCB\x3\x2\x2\x2\xCA\xCC\x5\x30\x19\x2\xCB");
            sb.Append("\xCA\x3\x2\x2\x2\xCB\xCC\x3\x2\x2\x2\xCC\'\x3\x2\x2\x2\xCD\xCE");
            sb.Append("\a\v\x2\x2\xCE\xCF\x5.\x18\x2\xCF)\x3\x2\x2\x2\xD0\xD1\a\f\x2");
            sb.Append("\x2\xD1\xD2\x5.\x18\x2\xD2+\x3\x2\x2\x2\xD3\xD4\a\r\x2\x2\xD4");
            sb.Append("\xD5\x5.\x18\x2\xD5-\x3\x2\x2\x2\xD6\xD7\x5h\x35\x2\xD7/\x3");
            sb.Append("\x2\x2\x2\xD8\xD9\a\xE\x2\x2\xD9\xDA\a \x2\x2\xDA\xDB\a\xF\x2");
            sb.Append("\x2\xDB\xE0\x5\x32\x1A\x2\xDC\xDD\a\x4\x2\x2\xDD\xDF\x5\x32");
            sb.Append("\x1A\x2\xDE\xDC\x3\x2\x2\x2\xDF\xE2\x3\x2\x2\x2\xE0\xDE\x3\x2");
            sb.Append("\x2\x2\xE0\xE1\x3\x2\x2\x2\xE1\xE3\x3\x2\x2\x2\xE2\xE0\x3\x2");
            sb.Append("\x2\x2\xE3\xE4\a\x10\x2\x2\xE4\x31\x3\x2\x2\x2\xE5\xE6\a\xF");
            sb.Append("\x2\x2\xE6\xE7\x5\x12\n\x2\xE7\xE8\a\x10\x2\x2\xE8\x33\x3\x2");
            sb.Append("\x2\x2\xE9\xEC\x5\x36\x1C\x2\xEA\xEC\a\x1F\x2\x2\xEB\xE9\x3");
            sb.Append("\x2\x2\x2\xEB\xEA\x3\x2\x2\x2\xEC\x35\x3\x2\x2\x2\xED\xEF\x5");
            sb.Append(":\x1E\x2\xEE\xF0\a#\x2\x2\xEF\xEE\x3\x2\x2\x2\xEF\xF0\x3\x2");
            sb.Append("\x2\x2\xF0\xF6\x3\x2\x2\x2\xF1\xF3\a\x4\x2\x2\xF2\xF4\a#\x2");
            sb.Append("\x2\xF3\xF2\x3\x2\x2\x2\xF3\xF4\x3\x2\x2\x2\xF4\xF5\x3\x2\x2");
            sb.Append("\x2\xF5\xF7\x5\x38\x1D\x2\xF6\xF1\x3\x2\x2\x2\xF6\xF7\x3\x2");
            sb.Append("\x2\x2\xF7\x37\x3\x2\x2\x2\xF8\xF9\x5j\x36\x2\xF9\xFA\a\n\x2");
            sb.Append("\x2\xFA\xFB\x5j\x36\x2\xFB\xFC\a\n\x2\x2\xFC\xFD\x5j\x36\x2");
            sb.Append("\xFD\xFE\a\n\x2\x2\xFE\xFF\x5j\x36\x2\xFF\x39\x3\x2\x2\x2\x100");
            sb.Append("\x101\x5h\x35\x2\x101\x102\a\n\x2\x2\x102\x104\x3\x2\x2\x2\x103");
            sb.Append("\x100\x3\x2\x2\x2\x104\x107\x3\x2\x2\x2\x105\x103\x3\x2\x2\x2");
            sb.Append("\x105\x106\x3\x2\x2\x2\x106\x108\x3\x2\x2\x2\x107\x105\x3\x2");
            sb.Append("\x2\x2\x108\x109\x5h\x35\x2\x109;\x3\x2\x2\x2\x10A\x10E\a\x1F");
            sb.Append("\x2\x2\x10B\x10E\x5> \x2\x10C\x10E\x5@!\x2\x10D\x10A\x3\x2\x2");
            sb.Append("\x2\x10D\x10B\x3\x2\x2\x2\x10D\x10C\x3\x2\x2\x2\x10E=\x3\x2");
            sb.Append("\x2\x2\x10F\x111\x5\\/\x2\x110\x10F\x3\x2\x2\x2\x110\x111\x3");
            sb.Append("\x2\x2\x2\x111\x113\x3\x2\x2\x2\x112\x114\a#\x2\x2\x113\x112");
            sb.Append("\x3\x2\x2\x2\x113\x114\x3\x2\x2\x2\x114\x115\x3\x2\x2\x2\x115");
            sb.Append("\x116\x5V,\x2\x116?\x3\x2\x2\x2\x117\x11A\x5\\/\x2\x118\x11A");
            sb.Append("\x5\x42\"\x2\x119\x117\x3\x2\x2\x2\x119\x118\x3\x2\x2\x2\x119");
            sb.Append("\x11A\x3\x2\x2\x2\x11A\x11C\x3\x2\x2\x2\x11B\x11D\a#\x2\x2\x11C");
            sb.Append("\x11B\x3\x2\x2\x2\x11C\x11D\x3\x2\x2\x2\x11D\x11E\x3\x2\x2\x2");
            sb.Append("\x11E\x120\x5V,\x2\x11F\x121\x5N(\x2\x120\x11F\x3\x2\x2\x2\x120");
            sb.Append("\x121\x3\x2\x2\x2\x121\x41\x3\x2\x2\x2\x122\x126\a\x11\x2\x2");
            sb.Append("\x123\x126\a\x12\x2\x2\x124\x126\x5\x44#\x2\x125\x122\x3\x2");
            sb.Append("\x2\x2\x125\x123\x3\x2\x2\x2\x125\x124\x3\x2\x2\x2\x126\x43");
            sb.Append("\x3\x2\x2\x2\x127\x129\a\x11\x2\x2\x128\x12A\a#\x2\x2\x129\x128");
            sb.Append("\x3\x2\x2\x2\x129\x12A\x3\x2\x2\x2\x12A\x12B\x3\x2\x2\x2\x12B");
            sb.Append("\x132\a\x12\x2\x2\x12C\x12E\a\x12\x2\x2\x12D\x12F\a#\x2\x2\x12E");
            sb.Append("\x12D\x3\x2\x2\x2\x12E\x12F\x3\x2\x2\x2\x12F\x130\x3\x2\x2\x2");
            sb.Append("\x130\x132\a\x11\x2\x2\x131\x127\x3\x2\x2\x2\x131\x12C\x3\x2");
            sb.Append("\x2\x2\x132\x45\x3\x2\x2\x2\x133\x136\a\x1F\x2\x2\x134\x136");
            sb.Append("\x5H%\x2\x135\x133\x3\x2\x2\x2\x135\x134\x3\x2\x2\x2\x136G\x3");
            sb.Append("\x2\x2\x2\x137\x138\a\xF\x2\x2\x138\x139\x5\x10\t\x2\x139\x13B");
            sb.Append("\a\x10\x2\x2\x13A\x13C\a#\x2\x2\x13B\x13A\x3\x2\x2\x2\x13B\x13C");
            sb.Append("\x3\x2\x2\x2\x13C\x13D\x3\x2\x2\x2\x13D\x13E\x5N(\x2\x13EI\x3");
            sb.Append("\x2\x2\x2\x13F\x142\a\x1F\x2\x2\x140\x142\x5L\'\x2\x141\x13F");
            sb.Append("\x3\x2\x2\x2\x141\x140\x3\x2\x2\x2\x142K\x3\x2\x2\x2\x143\x147");
            sb.Append("\x5P)\x2\x144\x147\x5R*\x2\x145\x147\x5T+\x2\x146\x143\x3\x2");
            sb.Append("\x2\x2\x146\x144\x3\x2\x2\x2\x146\x145\x3\x2\x2\x2\x147\x148");
            sb.Append("\x3\x2\x2\x2\x148\x149\x5N(\x2\x149M\x3\x2\x2\x2\x14A\x14C\a");
            sb.Append("\x13\x2\x2\x14B\x14D\a#\x2\x2\x14C\x14B\x3\x2\x2\x2\x14C\x14D");
            sb.Append("\x3\x2\x2\x2\x14D\x15C\x3\x2\x2\x2\x14E\x159\x5X-\x2\x14F\x151");
            sb.Append("\a#\x2\x2\x150\x14F\x3\x2\x2\x2\x150\x151\x3\x2\x2\x2\x151\x152");
            sb.Append("\x3\x2\x2\x2\x152\x154\a\x4\x2\x2\x153\x155\a#\x2\x2\x154\x153");
            sb.Append("\x3\x2\x2\x2\x154\x155\x3\x2\x2\x2\x155\x156\x3\x2\x2\x2\x156");
            sb.Append("\x158\x5X-\x2\x157\x150\x3\x2\x2\x2\x158\x15B\x3\x2\x2\x2\x159");
            sb.Append("\x157\x3\x2\x2\x2\x159\x15A\x3\x2\x2\x2\x15A\x15D\x3\x2\x2\x2");
            sb.Append("\x15B\x159\x3\x2\x2\x2\x15C\x14E\x3\x2\x2\x2\x15C\x15D\x3\x2");
            sb.Append("\x2\x2\x15D\x15F\x3\x2\x2\x2\x15E\x160\a#\x2\x2\x15F\x15E\x3");
            sb.Append("\x2\x2\x2\x15F\x160\x3\x2\x2\x2\x160\x161\x3\x2\x2\x2\x161\x162");
            sb.Append("\a\x14\x2\x2\x162O\x3\x2\x2\x2\x163\x165\a#\x2\x2\x164\x163");
            sb.Append("\x3\x2\x2\x2\x164\x165\x3\x2\x2\x2\x165\x166\x3\x2\x2\x2\x166");
            sb.Append("\x167\a\xF\x2\x2\x167\x168\a\x1F\x2\x2\x168\x16A\a\x10\x2\x2");
            sb.Append("\x169\x16B\a#\x2\x2\x16A\x169\x3\x2\x2\x2\x16A\x16B\x3\x2\x2");
            sb.Append("\x2\x16B\x16C\x3\x2\x2\x2\x16C\x16D\a\xF\x2\x2\x16D\x16E\x5");
            sb.Append("\x10\t\x2\x16E\x16F\a\x15\x2\x2\x16FQ\x3\x2\x2\x2\x170\x172");
            sb.Append("\x5\\/\x2\x171\x173\a#\x2\x2\x172\x171\x3\x2\x2\x2\x172\x173");
            sb.Append("\x3\x2\x2\x2\x173\x174\x3\x2\x2\x2\x174\x175\a\xF\x2\x2\x175");
            sb.Append("\x176\a\x1F\x2\x2\x176\x178\a\x10\x2\x2\x177\x179\a#\x2\x2\x178");
            sb.Append("\x177\x3\x2\x2\x2\x178\x179\x3\x2\x2\x2\x179\x17A\x3\x2\x2\x2");
            sb.Append("\x17A\x17B\a\xF\x2\x2\x17B\x17C\x5\x10\t\x2\x17C\x17D\a\x16");
            sb.Append("\x2\x2\x17DS\x3\x2\x2\x2\x17E\x180\x5\\/\x2\x17F\x17E\x3\x2");
            sb.Append("\x2\x2\x17F\x180\x3\x2\x2\x2\x180\x182\x3\x2\x2\x2\x181\x183");
            sb.Append("\a#\x2\x2\x182\x181\x3\x2\x2\x2\x182\x183\x3\x2\x2\x2\x183\x184");
            sb.Append("\x3\x2\x2\x2\x184\x186\x5V,\x2\x185\x187\x5\x30\x19\x2\x186");
            sb.Append("\x185\x3\x2\x2\x2\x186\x187\x3\x2\x2\x2\x187U\x3\x2\x2\x2\x188");
            sb.Append("\x189\a\xF\x2\x2\x189\x18A\x5\x10\t\x2\x18A\x18C\a\x10\x2\x2");
            sb.Append("\x18B\x18D\a#\x2\x2\x18C\x18B\x3\x2\x2\x2\x18C\x18D\x3\x2\x2");
            sb.Append("\x2\x18D\x18E\x3\x2\x2\x2\x18E\x18F\a\xF\x2\x2\x18F\x190\x5");
            sb.Append("\x10\t\x2\x190\x191\a\x17\x2\x2\x191\x192\x5h\x35\x2\x192W\x3");
            sb.Append("\x2\x2\x2\x193\x195\a#\x2\x2\x194\x193\x3\x2\x2\x2\x194\x195");
            sb.Append("\x3\x2\x2\x2\x195\x196\x3\x2\x2\x2\x196\x198\x5Z.\x2\x197\x194");
            sb.Append("\x3\x2\x2\x2\x197\x198\x3\x2\x2\x2\x198\x19A\x3\x2\x2\x2\x199");
            sb.Append("\x19B\a#\x2\x2\x19A\x199\x3\x2\x2\x2\x19A\x19B\x3\x2\x2\x2\x19B");
            sb.Append("\x19C\x3\x2\x2\x2\x19C\x19D\a\xF\x2\x2\x19D\x19E\x5\x10\t\x2");
            sb.Append("\x19E\x1A0\a\x10\x2\x2\x19F\x1A1\a#\x2\x2\x1A0\x19F\x3\x2\x2");
            sb.Append("\x2\x1A0\x1A1\x3\x2\x2\x2\x1A1\x1A2\x3\x2\x2\x2\x1A2\x1A3\x5");
            sb.Append("h\x35\x2\x1A3Y\x3\x2\x2\x2\x1A4\x1AA\x5^\x30\x2\x1A5\x1AA\x5");
            sb.Append("`\x31\x2\x1A6\x1AA\x5\x62\x32\x2\x1A7\x1AA\x5\x64\x33\x2\x1A8");
            sb.Append("\x1AA\x5\x66\x34\x2\x1A9\x1A4\x3\x2\x2\x2\x1A9\x1A5\x3\x2\x2");
            sb.Append("\x2\x1A9\x1A6\x3\x2\x2\x2\x1A9\x1A7\x3\x2\x2\x2\x1A9\x1A8\x3");
            sb.Append("\x2\x2\x2\x1AA[\x3\x2\x2\x2\x1AB\x1AC\a\x18\x2\x2\x1AC]\x3\x2");
            sb.Append("\x2\x2\x1AD\x1AE\a\x19\x2\x2\x1AE_\x3\x2\x2\x2\x1AF\x1B0\a\x1A");
            sb.Append("\x2\x2\x1B0\x61\x3\x2\x2\x2\x1B1\x1B2\a\x1B\x2\x2\x1B2\x63\x3");
            sb.Append("\x2\x2\x2\x1B3\x1B4\a\x1C\x2\x2\x1B4\x65\x3\x2\x2\x2\x1B5\x1B6");
            sb.Append("\a\x1D\x2\x2\x1B6g\x3\x2\x2\x2\x1B7\x1BD\a!\x2\x2\x1B8\x1BC");
            sb.Append("\a!\x2\x2\x1B9\x1BC\x5j\x36\x2\x1BA\x1BC\a\"\x2\x2\x1BB\x1B8");
            sb.Append("\x3\x2\x2\x2\x1BB\x1B9\x3\x2\x2\x2\x1BB\x1BA\x3\x2\x2\x2\x1BC");
            sb.Append("\x1BF\x3\x2\x2\x2\x1BD\x1BB\x3\x2\x2\x2\x1BD\x1BE\x3\x2\x2\x2");
            sb.Append("\x1BEi\x3\x2\x2\x2\x1BF\x1BD\x3\x2\x2\x2\x1C0\x1C1\t\x2\x2\x2");
            sb.Append("\x1C1k\x3\x2\x2\x2\x38\x86\x8A\x8E\x91\x98\x9C\xA0\xB3\xB6\xBF");
            sb.Append("\xC3\xC8\xCB\xE0\xEB\xEF\xF3\xF6\x105\x10D\x110\x113\x119\x11C");
            sb.Append("\x120\x125\x129\x12E\x131\x135\x13B\x141\x146\x14C\x150\x154");
            sb.Append("\x159\x15C\x15F\x164\x16A\x172\x178\x17F\x182\x186\x18C\x194");
            sb.Append("\x197\x19A\x1A0\x1A9\x1BB\x1BD");
            return sb.ToString();
        }

        public static readonly ATN _ATN =
            new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
    }
} // namespace KaVE.Commons.Model.Names.CSharp.Parser